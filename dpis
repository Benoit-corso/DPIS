#! /usr/bin/python3
import importlib
import argparse
import platform
import signal
import sys
import os
import re
import scapy.all as scapy
from lib import logger, sniffer as sniff

# Regex for checking mac address
r_mac = re.compile('^(([0-9a-f]{2})(:(?!$)|$)){6}$', re.IGNORECASE)
# Regex for checking ip address
r_iadr = re.compile('^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$')
# Regex for checking port
r_port = re.compile('^((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9]{2})|(6[0-4][0-9]{3})|([1-5][0-9]{4})|([0-5]{0,5})|([0-9]{1,4}))$')

targets = 0
log     = None

class Target:
    name        = ""
    ip          = ""
    mac         = ""
    valid       = False
    def get_mac(self, ip) -> bool:
        global r_mac
        # ARP request
        req = scapy.ARP(pdst=ip)
        # Broadcast Ethernet layer
        brd = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        # Build the packet
        arp_req = brd / req
        # Wait for the response (2 seconds)
        res = scapy.srp(arp_req, timeout=2, verbose=False)[0]
        # getting the MAC
        self.mac = res[0][1].hwsrc
        if r_mac.match(self.mac):
            self.valid = True
        return self.valid

    def __init__(self, ip, name = ""):
        global r_iadr, r_mac, targets
        if len(name) == 0:
            name = "target"+str(targets)
        if r_iadr.match(ip):
            self.name   = name
            self.ip     = ip
            targets     = targets + 1
        else: log.print("bad ip address for target {} got: {}".format(name, ip))
        if not self.get_mac():
            log.print("failed to get mac address for target {}".format(name))
        else:
            log.print("new target defined with name {}".format(name))

# Dynamic Protocol Injector Sniffer (called Deep-Peace)
class DPIS:
    # define our instance variables
#   logger      = None
    sniffer     = None
    spoofer     = None
    firewall    = None
    protocol    = None

    # host interface we're listening to
    iface       = ""
    # host informations [ip, mac]
    host        = ["", ""]
    # protocol informations [name, port]
    proto       = ["", 0]
    # gateway informations Target(gateway)
    gateway     = None
    # target informations (server) Target(server)
    target      = None
    # victims List[Target(), ...]
    victims     = []
    # toggle stdin for incoming datas
    stdin       = False
    # enable socket to intercept datas
    socket      = None
    def __init__(self, iface, proto, target, spoof = False, firewall = False, *_):
        global r_port;
        self.iface      = iface
        self.host       = [scapy.get_if_addr(iface), scapy.get_if_hwaddr(iface)]
        log.print("current host informations:\n\tinterface:\t{}\n\tip:\t{}\n\tmac:\t{}".format(iface, self.host[0], self.host[1]))
        self.gateway    = Target(scapy.conf.route.route('0.0.0.0')[2], "gateway")
        self.target     = Target(target, "server")
        # Split the port argument into protocol and port
        self.proto      = proto.split(':')
        # Make sure Port format is OK
        if not r_port.match(self.proto[1]):
            log.print("\x1b[0;31;40mInvalid target port!\x1b[0m")
            exit(0)
        else:
            self.protocol = importlib.import_module("lib.proto."+self.proto[0]).protocol
            log.print("protocol {} selected on port {}".format(self.proto[0], self.proto[1]))
        if firewall:
            self.firewall = firewall
        if spoof:
            self.spoofer = spoof

    # Start instances and threads.
    def start(self) -> bool:
        self.protocol.start()
        if self.firewall is not None:
            log.print("Enabling firewall rules...")
        if self.spoofer is not None:
            log.print("Starting spoofer, please wait for a while...")
        log.print("Sniffing on port {}".format(self.proto[1]))
        self.sniffer = sniff.sniffer(self.proto[1])
        self.sniffer.start()

    # Stop threads and exit program.
    def stop(self, *_) -> None:
        global log
        log.print("Killing threads and exiting...")
        self.sniffer.stop()
        if self.spoofer is not None:
            self.spoofer.stop()
        if self.protocol is not None:
            self.protocol.stop()
        sys.exit(0)

    # Execute readline for specified protocol.
    def stdin(self) -> None:
        True

# Main function, parses every arguments and return dyn class
def main():
    os.system('color')
    # import global settings(get all Var)
    global log, r_iadr
    print ("""\x1b[0;32;40m
      :::::::::  ::::::::: ::::::::::: :::::::: 
     :+:    :+: :+:    :+:    :+:    :+:    :+: 
    +:+    +:+ +:+    +:+    +:+    +:+         
   +#+    +:+ +#++:++#+     +#+    +#++:++#++   
  +#+    +#+ +#+           +#+           +#+ by Rmalet, N0x4z3r
 #+#    #+# #+#           #+#    #+#    #+#\x1b[0;33;40m mitm\x1b[0;32;40m
#########  ###       ########### ########\x1b[0m

    Dynamic Protocols Injection and Spoofing
    (called Deep-Peace)""")

    if platform.system() == "Windows":
        try:
            import pyuac
        #    if not pyuac.isUserAdmin():
        #        print("\x1b[0;31;40mThis program should be run as Administrator.\x1b[0m")
        #        #rc = pyuac.runAsAdmin()
        #        exit(1)
        except Exception as E:
            if type(E.args[0]) == str and "No module" in E.args[0]:
                module = E.args[0].split(' ')
                if "win32con" in module:
                    module = "'pypiwin32'"
                print("\x1b[0;31;40mShould install {} on windows platform.\x1b[0m".format(module[len(module) - 1]))
                print(E)
            else:
                print(E)
            exit(1)
    # Make sure the script is being run as root
    elif os.geteuid() != 0:
        print("\x1b[0;31;40mThis program should be run as root.\x1b[0m")
        exit(1)

    # Parser to handle command-line arguments
    parser = argparse.ArgumentParser()

    #Optionnal firewall settings
    firewall = parser.add_mutually_exclusive_group(required=False)
    firewall.add_argument("-f", "--firewall",
                        help="Create multiple firewall rules",
                        dest="firewall",
                        action='store_true')
    spoofing = parser.add_mutually_exclusive_group(required=False)
    spoofing.add_argument("-S", "--no-spoofing",
                        help="Disable ARP spoofing",
                        dest="spoofing",
                        action='store_false')
    # optionnal: control the verbosity of the program 0 = Silent 3 = most verbose
    parser.add_argument("-v", "--verbose",
                        help="Display more informations",
                        choices=[0, 1, 2, 3],
                        required=False,
                        default=0,
                        type=int)
    # Set the defaults values for optional arguments
    parser.set_defaults(firewall=False, spoofing=True)

    #Optional : Arg to write in a .pcap file
    #parser.add_argument("-w", "--write", help="create a pcap file.", required=False, default=False)
    # Optional : Arg to execute a terminal protocl via standard input 
    parser.add_argument("-s", "--stdin",
                        help="try to execute a terminal protocol.",
                        required=False,
                        default=False,
                        action='store_true')
    #Argument for the network interface listener
    parser.add_argument("iface", help="Set interface listening to")
    #Arguement for the port destination
    parser.add_argument("protocol", help="Define the protocol and port <name>:<port>")
    #Argument for the ip source
    parser.add_argument("target", help="Targeted ip address (most of cases server ip address)")
    #Argument for the ip source
    parser.add_argument("victims", help="List of victims ip address")

    # parse command-line argument
    args = parser.parse_args()
    # Create our logger instance
    log = logger.log(args.verbose)

    if len(args.iface) == 0:
        log.print("\x1b[0;31;40mBad argument <iface> got empty value.\x1b[0m")
        exit(1)
    else:
        ifaces = scapy.get_working_ifaces()
        if not args.iface in ifaces:
            log.print("\x1b[0;31;40mInterface {} doesn't exist or isn't working. printing valid interfaces:\n\t{}\x1b[0m".format(args.iface, ifaces))
            exit(1)

    if not ":" in args.protocol:
        log.print("\x1b[0;31;40mBad argument for <protocol> should specify <proto_name>:<port>\x1b[0m")
        exit(1)

    if len(args.target) == 0 or not r_iadr.match(args.target):
        log.print("\x1b[0;31;40mBad argument for <target>\x1b[0m")
        exit(1)

    if ":" in args.victims:
        args.victims = args.victims.split(":")
        if len(args.victims) == 0:
            log.print("\x1b[0;31;40mBad argument for <victims>. Should specify at least one victim.\n\tformat: <victim>:<victim>\x1b[0m")
            exit(1)
        else:
            i = 0
            for victim in args.victims:
                if not r_iadr.match(victim):
                    log.print("\x1b[0;31;40mBad ip address for victim number {}, got: {}\x1b[0m".format(i, victim))
                    exit(1)
                i = i + 1
    else:
        if not r_iadr.match(args.victims):
            log.print("\x1b[0;31;40mBad ip address for victim, got: {}\x1b[0m".format(args.victims))
            exit(1)
        else:
            args.victims = [args.victims]

    return DPIS(args.iface, args.protocol, args.target, args.spoofing, args.firewall, *args.victims);
    # While the programe is running, accepting stdin process incoming data
    while args.stdin:
        payload = sys.stdin.readline()
        ready = lpkt.psh(payload)
        lpkt.send(ready)

if __name__ == "__main__":
    # Call the main fonction
    program = main()
    # Catch interrupt signal and run exit functions
    signal.signal(signal.SIGINT, program.exit)
    program.start()
